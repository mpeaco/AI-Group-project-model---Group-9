# TWO FUNCTIONS

# Function 1-   retrieve an svg file which has alrady had relativeToAbsolute run on it
#               and split it into a series of beginning + end points, with a reference to
#               the original line in full

# Function 2-   add together the distance of a path, generated by a seperate pathfinding function

# OBVIOUS QUESTION:
# given were pathfinding with lines rather than points, which is preferable?
# opt 1. when checking paths, flip every line individually to find fastest version of that path
# opt 2. when calculating paths, have flipping the line as an option
# i lean towards option 2 because option 1 seems very computationally expensive, but we will see when
# we get there

import numpy as np
import matplotlib.pyplot as plt
import random
import math
import time
from relative_to_absolute import writeSvg


def judgeDistance(linesList):

    # for the input image tested with, each run takes
    # 0.00021 seconds
    # could be more efficient, but will do for now
    # over time, comes out roughly 6x faster than previous method
    # (math.dist is coded in c, so is faster than same code in py)

    distance = 0
    for line in linesList:
        start = line[0]
        try:
            # capture the distance between segments
            # (and save time if segment starts where the previous one ends)
            if start != end:
                distance += math.dist(start, end)
        except:
            # on the first iteration, end has not yet been set
            pass
        end = line[1]
        distance += math.dist(start, end)

    return distance


def processFile(location):
    with open(location, "r") as file:
        svgData = file.read()

    lines = []
    linesOriginal = []

    for line in svgData.splitlines():
        if line[:8] == "<path d=":   #note this would be unreliable, but were writing the file ourselves
            temp = line.split(" ")
            temp.pop(0)
            temp.pop(0)
            temp2 = [[float(temp[0]), float(temp[1])], [float(temp[-2]), float(temp[-1][:-3])], len(linesOriginal)]
            lines.append(temp2)
        linesOriginal.append(line)
    
    return linesOriginal, lines



def preview(linesList):

    # creates a pyplot graph showing the current path of printer
    # assumes input in the format:
    # [[[point1x, point1y], [point2x, point2y], (artitrary beyond these points)], ...]
    
    for line in linesList:
        start = line[0]
        try:
            if start != end:
                plt.plot([start[0], end[0]], [start[1], end[1]], color="blue", linestyle="dashed", zorder=1)
        except:
            pass
        end = line[1]
        
        plt.plot([start[0], end[0]], [start[1], end[1]], color="red", linestyle="dashed", zorder=3)

        plt.scatter([start[0], end[0]], [start[1], end[1]], color="black", zorder=2)

    plt.show()

def restoreFile(linesOriginal, linesMixed):
    temp2 = np.arange(0, len(linesOriginal))
    body = []
    for line in linesMixed:
        temp = linesOriginal[line[2]].split(" ")
        #print(temp[2:4])
        if line[0] == [float(temp[2]), float(temp[3])]:
            #print("YES")
            if line[1] == [float(temp[-2]), float(temp[-1][:-3])]:
                temp2 = np.delete(temp2, np.where(temp2 == line[2]))
                body.append(linesOriginal[line[2]])
                pass
            else:
                print("ERR 2 ", line, linesOriginal[line[2]])
        else:
            print("ERR 1 ", line, linesOriginal[line[2]])
    print(temp2, "B")
    stored = -1
    header = []
    footer = []
    for ind in temp2:
        if ind != stored + 1:
            break
        stored = ind
        header.append(linesOriginal[ind])
    temp2 = temp2[stored+1:]
    for ind in temp2:
        footer.append(linesOriginal[ind])
    del temp2
    output = header + body + footer
    return output


def main():
    print(":D")
    pathGuy = r"C:\Users\MillerN\Desktop\AI\Group Project\output.svg"
    linesFull, linesCoords = processFile(pathGuy)
    random.shuffle(linesCoords)
    timer1 = time.time()
    print(judgeDistance(linesCoords))
    timer2 = time.time()
    print(timer2-timer1)
    guy = restoreFile(linesFull, linesCoords)

    writeSvg(guy, "output2.svg")
    #preview(linesCoords)

if __name__ == "__main__":
    main()