# TWO FUNCTIONS

# Function 1-   retrieve an svg file which has alrady had relativeToAbsolute run on it
#               and split it into a series of beginning + end points, with a reference to
#               the original line in full

# Function 2-   add together the distance of a path, generated by a seperate pathfinding function

# OBVIOUS QUESTION:
# given were pathfinding with lines rather than points, which is preferable?
# opt 1. when checking paths, flip every line individually to find fastest version of that path
# opt 2. when calculating paths, have flipping the line as an option
# i lean towards option 2 because option 1 seems very computationally expensive, but we will see when
# we get there

import numpy as np
import math
from relative_to_absolute import writeSvg


def judgeDistance(linesList):

    # for the input image tested with, each run takes
    # 0.00021 seconds
    # could be more efficient, but will do for now
    # over time, comes out roughly 6x faster than previous method
    # (math.dist is coded in c, so is faster than same code in py)

    distance = 0
    for line in linesList:
        start = line[0]
        try:
            # capture the distance between segments
            # (and save time if segment starts where the previous one ends)
            if start != end:
                distance += math.dist(start, end)
        except:
            # on the first iteration, end has not yet been set
            pass
        end = line[1]
        distance += math.dist(start, end)

    return distance


def processFile(location):
    with open(location, "r") as file:
        svgData = file.read()

    lines = []
    linesOriginal = []

    for line in svgData.splitlines():
        if line[:8] == "<path d=":   #note this would be unreliable, but were writing the file ourselves
            temp = line.split(" ")
            temp.pop(0)
            temp.pop(0)
            temp2 = [[float(temp[0]), float(temp[1])], [float(temp[-2]), float(temp[-1][:-3])], len(linesOriginal)]
            lines.append(temp2)
        linesOriginal.append(line)
    
    return linesOriginal, lines


def restoreFile(linesOriginal, linesMixed):
    temp2 = np.arange(0, len(linesOriginal))
    body = []
    for line in linesMixed:
        temp = linesOriginal[line[2]].split(" ")
        if line[0] == [float(temp[2]), float(temp[3])]:
            if line[1] == [float(temp[-2]), float(temp[-1][:-3])]:
                temp2 = np.delete(temp2, np.where(temp2 == line[2]))
                body.append(linesOriginal[line[2]])
            else:
                print("Error in line end coordinates")
        else:
            print("Error in line start coordinates")
    stored = -1
    header = []
    footer = []
    for ind in temp2:
        if ind != stored + 1:
            break
        stored = ind
        header.append(linesOriginal[ind])
    temp2 = temp2[stored+1:]
    for ind in temp2:
        footer.append(linesOriginal[ind])
    del temp2
    output = header + body + footer
    return output